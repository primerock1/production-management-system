# Пояснения по коду калькулятора сырья

## Обзор функционала

Калькулятор сырья - это модуль для расчета необходимого количества материалов для производства продукции с учетом:
- Параметров продукции (длина, ширина)
- Коэффициента типа продукции
- Процента потерь материала
- Количества изделий

## Файл: backend/app/services/material_calculator.py

### Класс MaterialCalculatorService

```python
class MaterialCalculatorService:
    """Сервис для расчета сырья с учетом потерь"""
    
    def __init__(self, db: Session):
        self.db = db
```

**Назначение:**
- Инкапсуляция бизнес-логики расчетов
- Работа с базой данных через SQLAlchemy сессию
- Изоляция алгоритма от API слоя

### Основной метод расчета

```python
def calculate_raw_material(
    self,
    product_type_id: int,
    material_type_id: int,
    quantity: int,
    param1: float,
    param2: float
) -> int:
```

**Параметры:**
- `product_type_id` - ID типа продукции (для получения коэффициента)
- `material_type_id` - ID типа материала (для получения процента потерь)
- `quantity` - количество изделий для производства
- `param1` - первый параметр продукции (обычно длина)
- `param2` - второй параметр продукции (обычно ширина)

**Возвращает:**
- Положительное число - количество сырья с учетом потерь
- `-1` - при ошибке или некорректных данных

### Валидация входных данных

```python
# Проверяем входные данные
if quantity <= 0 or param1 <= 0 or param2 <= 0:
    return -1
```

**Логика проверки:**
- Все числовые параметры должны быть положительными
- Нулевые или отрицательные значения недопустимы
- Возврат -1 сигнализирует об ошибке

### Получение данных из базы

```python
# Получаем тип продукции
product_type = self.db.query(ProductType).filter(
    ProductType.id == product_type_id
).first()

# Получаем тип материала
material_type = self.db.query(MaterialType).filter(
    MaterialType.id == material_type_id
).first()

if not product_type or not material_type:
    return -1
```

**Безопасность:**
- Проверка существования записей в БД
- Использование ORM для защиты от SQL-инъекций
- Возврат ошибки при отсутствии данных

### Алгоритм расчета

```python
# Рассчитываем базовое количество сырья на единицу продукции
# Формула: param1 * param2 * коэффициент_типа_продукции
base_material_per_unit = param1 * param2 * product_type.coefficient

# Общее количество сырья без учета потерь
total_base_material = base_material_per_unit * quantity

# Учитываем потери сырья
# Формула: базовое_количество * (1 + процент_потерь/100)
loss_multiplier = 1 + (material_type.loss_percentage / 100)
total_material_with_losses = total_base_material * loss_multiplier

# Возвращаем целое число (округляем вверх для гарантии достаточности)
import math
return math.ceil(total_material_with_losses)
```

**Пошаговый расчет:**

1. **Базовое количество на единицу:**
   ```
   base_per_unit = длина × ширина × коэффициент_типа
   ```

2. **Общее базовое количество:**
   ```
   total_base = base_per_unit × количество_изделий
   ```

3. **Учет потерь:**
   ```
   multiplier = 1 + (процент_потерь / 100)
   total_with_losses = total_base × multiplier
   ```

4. **Округление вверх:**
   ```
   result = ceil(total_with_losses)
   ```

**Пример расчета:**
```
Входные данные:
- Длина: 1.5 м
- Ширина: 2.0 м  
- Коэффициент типа: 1.2
- Количество: 10 шт
- Потери материала: 5%

Расчет:
1. base_per_unit = 1.5 × 2.0 × 1.2 = 3.6 м²
2. total_base = 3.6 × 10 = 36 м²
3. multiplier = 1 + (5/100) = 1.05
4. total_with_losses = 36 × 1.05 = 37.8 м²
5. result = ceil(37.8) = 38 м²
```

### Обработка исключений

```python
except Exception as e:
    print(f"Ошибка при расчете сырья: {e}")
    return -1
```

**Стратегия:**
- Перехват всех исключений
- Логирование ошибки для отладки
- Возврат -1 как индикатор ошибки
- Предотвращение падения приложения

### Функция-обертка

```python
def calculate_material_for_product(
    db: Session,
    product_type_id: int,
    material_type_id: int,
    quantity: int,
    param1: float,
    param2: float
) -> int:
    """
    Функция-обертка для расчета сырья
    """
    calculator = MaterialCalculatorService(db)
    return calculator.calculate_raw_material(
        product_type_id=product_type_id,
        material_type_id=material_type_id,
        quantity=quantity,
        param1=param1,
        param2=param2
    )
```

**Назначение:**
- Упрощение использования сервиса
- Создание экземпляра калькулятора
- Функциональный интерфейс для API

## Файл: backend/app/routers/material_calculator.py

### Pydantic модели для валидации

```python
class MaterialCalculationRequest(BaseModel):
    """Запрос на расчет сырья"""
    product_type_id: int = Field(..., description="ID типа продукции")
    material_type_id: int = Field(..., description="ID типа материала")
    quantity: int = Field(..., gt=0, description="Количество продукции")
    param1: float = Field(..., gt=0, description="Первый параметр (например, длина)")
    param2: float = Field(..., gt=0, description="Второй параметр (например, ширина)")
```

**Валидация:**
- `Field(...)` - обязательные поля
- `gt=0` - больше нуля для quantity, param1, param2
- `description` - документация для Swagger UI
- Автоматическая типизация и проверка

```python
class MaterialCalculationResponse(BaseModel):
    """Ответ с результатом расчета"""
    required_material: int = Field(..., description="Необходимое количество сырья")
    product_type_id: int
    material_type_id: int
    quantity: int
    param1: float
    param2: float
    success: bool = Field(..., description="Успешность расчета")
    message: str = Field(..., description="Сообщение о результате")
```

**Структура ответа:**
- Дублирование входных данных для проверки
- Флаг успешности операции
- Человекочитаемое сообщение
- Типизированный результат

### API endpoint для расчета

```python
@router.post("/calculate-material", response_model=MaterialCalculationResponse)
def calculate_required_material(
    request: MaterialCalculationRequest,
    db: Session = Depends(get_db)
):
```

**Особенности:**
- POST метод для передачи сложных данных
- Автоматическая валидация через Pydantic
- Dependency Injection для сессии БД
- Типизированный ответ

### Обработка результата расчета

```python
result = calculate_material_for_product(
    db=db,
    product_type_id=request.product_type_id,
    material_type_id=request.material_type_id,
    quantity=request.quantity,
    param1=request.param1,
    param2=request.param2
)

if result == -1:
    return MaterialCalculationResponse(
        required_material=-1,
        product_type_id=request.product_type_id,
        material_type_id=request.material_type_id,
        quantity=request.quantity,
        param1=request.param1,
        param2=request.param2,
        success=False,
        message="Ошибка расчета: неверные данные или несуществующие типы"
    )
```

**Логика:**
- Вызов сервиса расчета
- Проверка результата на ошибку (-1)
- Формирование соответствующего ответа
- Сохранение входных данных в ответе

### Успешный результат

```python
return MaterialCalculationResponse(
    required_material=result,
    product_type_id=request.product_type_id,
    material_type_id=request.material_type_id,
    quantity=request.quantity,
    param1=request.param1,
    param2=request.param2,
    success=True,
    message=f"Для производства {request.quantity} единиц продукции потребуется {result} единиц сырья"
)
```

**Детали:**
- Возврат рассчитанного количества
- Формирование информативного сообщения
- Флаг успешности True
- Полная трассируемость данных

### API для цехов продукта

```python
@router.get("/workshops-for-product/{product_id}", response_model=List[WorkshopForProductResponse])
def get_workshops_for_product(
    product_id: int,
    db: Session = Depends(get_db)
):
```

**Функциональность:**
- Получение списка цехов для конкретного продукта
- Информация о времени производства в каждом цехе
- Данные о персонале цехов

### SQL запрос с JOIN

```python
workshops_query = db.query(
    ProductWorkshop.workshop_id,
    Workshop.name,
    Workshop.workshop_type,
    Workshop.staff_count,
    ProductWorkshop.production_time_hours
).join(
    Workshop, ProductWorkshop.workshop_id == Workshop.id
).filter(
    ProductWorkshop.product_id == product_id
)
```

**Особенности:**
- JOIN между таблицами product_workshops и workshops
- Выборка только нужных полей
- Фильтрация по ID продукта
- Использование SQLAlchemy ORM

### Расчет общего времени производства

```python
@router.get("/total-production-time/{product_id}")
def get_total_production_time(
    product_id: int,
    db: Session = Depends(get_db)
):
    # Получаем общее время производства
    total_time = db.query(
        db.func.sum(ProductWorkshop.production_time_hours)
    ).filter(
        ProductWorkshop.product_id == product_id
    ).scalar()
```

**SQL функции:**
- `func.sum()` - агрегатная функция суммирования
- `scalar()` - получение единственного значения
- Обработка NULL результата

## Интеграция с фронтендом

### JavaScript API клиент

```javascript
const calculatorAPI = {
    calculateMaterial: (data) => api.post('/calculator/calculate-material', data),
    getWorkshopsForProduct: (productId) => api.get(`/calculator/workshops-for-product/${productId}`),
    getTotalProductionTime: (productId) => api.get(`/calculator/total-production-time/${productId}`)
};
```

### Обработка формы расчета

```javascript
const formData = {
    product_type_id: parseInt(document.getElementById('calc-product-type').value),
    material_type_id: parseInt(document.getElementById('calc-material-type').value),
    quantity: parseInt(document.getElementById('calc-quantity').value),
    param1: parseFloat(document.getElementById('calc-param1').value),
    param2: parseFloat(document.getElementById('calc-param2').value)
};

try {
    const result = await calculatorAPI.calculateMaterial(formData);
    displayCalculationResult(result);
} catch (error) {
    console.error('Ошибка расчета:', error);
    showToast('Ошибка при расчете сырья: ' + error.message, 'error');
}
```

### Отображение результата

```javascript
function displayCalculationResult(result) {
    const resultDiv = document.getElementById('calculation-result');
    
    if (result.success) {
        resultDiv.innerHTML = `
            <div class="alert alert-success">
                <h4><i class="fas fa-check-circle me-2"></i>Расчет выполнен успешно</h4>
                <div class="row text-start">
                    <div class="col-md-6">
                        <strong>Исходные данные:</strong>
                        <ul class="list-unstyled mt-2">
                            <li>Количество: ${result.quantity} шт.</li>
                            <li>Параметр 1: ${result.param1}</li>
                            <li>Параметр 2: ${result.param2}</li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <strong>Результат:</strong>
                        <div class="mt-2">
                            <span class="badge bg-primary fs-6">
                                ${result.required_material} единиц сырья
                            </span>
                        </div>
                    </div>
                </div>
                <p class="mb-0 mt-3"><small>${result.message}</small></p>
            </div>
        `;
    }
}
```

## Тестирование калькулятора

### Тестовые случаи

1. **Нормальный расчет:**
   ```json
   {
     "product_type_id": 1,
     "material_type_id": 2,
     "quantity": 10,
     "param1": 1.5,
     "param2": 2.0
   }
   ```

2. **Нулевые параметры:**
   ```json
   {
     "product_type_id": 1,
     "material_type_id": 2,
     "quantity": 0,
     "param1": 1.5,
     "param2": 2.0
   }
   ```
   Ожидаемый результат: `required_material: -1, success: false`

3. **Несуществующий тип:**
   ```json
   {
     "product_type_id": 999,
     "material_type_id": 2,
     "quantity": 10,
     "param1": 1.5,
     "param2": 2.0
   }
   ```
   Ожидаемый результат: `required_material: -1, success: false`

### Проверка через Swagger UI

1. Откройте http://localhost:8000/docs
2. Найдите раздел "calculator"
3. Выберите POST /api/calculator/calculate-material
4. Нажмите "Try it out"
5. Введите тестовые данные
6. Нажмите "Execute"
7. Проверьте результат

## Принципы проектирования

### 1. Разделение ответственности
- **Сервис** - бизнес-логика расчетов
- **Роутер** - HTTP интерфейс и валидация
- **Модели** - структуры данных

### 2. Валидация на всех уровнях
- **Pydantic** - валидация входных данных
- **Сервис** - бизнес-правила
- **База данных** - ограничения целостности

### 3. Обработка ошибок
- Возврат -1 при ошибках расчета
- HTTP статусы для API ошибок
- Информативные сообщения пользователю

### 4. Производительность
- Минимальные запросы к БД
- Эффективные SQL запросы
- Кэширование на фронтенде

### 5. Расширяемость
- Легко добавить новые типы расчетов
- Модульная архитектура
- Типизированные интерфейсы

Этот калькулятор обеспечивает точные расчеты сырья с учетом всех производственных факторов и может быть легко расширен для других типов расчетов.